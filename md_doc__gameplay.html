<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GT RoboCup SSL: Gameplay</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rj_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GT RoboCup SSL
   </div>
   <div id="projectbrief">Soccer software, robot firmware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc__gameplay.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Gameplay </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document covers the basics of our high-level soccer code including Plays, Behaviors, and game state evaluation. This code resides in <a href="https://github.com/RoboJackets/robocup-software/tree/master/soccer/gameplay">soccer/gameplay</a>.</p>
<p>As with any complex system, it's important to have some well-defined structure to keep things manageable. The <code>soccer</code> program is split up into several different layers for this purpose, with the gameplay layer being the most high-level. The gameplay layer is managed by the GameplayModule and evaluates the current state of the field (where the robots and ball are) and the state of the game (is it a kickoff, penalty kick, etc). This information is contained in the c++ <a class="el" href="class_system_state.html">SystemState</a> class and the <a class="el" href="class_game_state.html">GameState class</a>, respectively. The result of running the GameplayModule is a motion command for each of the robots as well as kick and dribble commands. Layers of the software stack below the gameplay layer ideally don't know anything about soccer and just orchestrate robot motion, radio communication, network communication, etc.</p>
<p>When the gameplay module is running, its job is to select the best play from a list of enabled plays by choosing the one with the lowest <a class="el" href="classgameplay_1_1play_1_1_play.html#aafa609875cbd8ae4db87cdfe9acb4281">score()</a> value. Plays are enabled and disabled through the GUI with the checkboxes next to play names. See the annotated screenshot below for more info.</p>
<div class="image">
<img src="soccer-with-gameplay-annotations.png" width="1000"/>
</div>
<h2>Play Structure</h2>
<p>The high-level strategy code is organized to be as modular as possible. To do this, it's been split up into three main parts: <a href="https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/skills">Skills</a>, <a href="https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/tactics">Tactics</a>, and <a href="https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/plays">Plays</a>. There is one Goalie (optionally) and one <a class="el" href="classgameplay_1_1play_1_1_play.html">Play</a> object.</p>
<p><b>Skills</b> are behaviors that apply to a single robot. They include things like <a class="el" href="classgameplay_1_1skills_1_1capture_1_1_capture.html">capturing the ball</a>, <a class="el" href="classgameplay_1_1skills_1_1move_1_1_move.html">moving to a particular position on the field</a>, and <a class="el" href="classgameplay_1_1skills_1_1pivot__kick_1_1_pivot_kick.html">kicking the ball</a>.</p>
<p><b>Tactics</b> can coordinate a single robot or many and generally encapsulate more complex behavior than <b>skills</b>. This includes things such as <a class="el" href="classgameplay_1_1tactics_1_1coordinated__pass_1_1_coordinated_pass.html">passing</a>, <a class="el" href="classgameplay_1_1tactics_1_1defense_1_1_defense.html">defense</a>, and <a class="el" href="classgameplay_1_1tactics_1_1positions_1_1goalie_1_1_goalie.html">the goalie</a>.</p>
<p><b>Plays</b> are responsible for coordinating the whole team of robots (although some robots may be unused). At a given time, the <code>soccer</code> program is running at most one play.</p>
<p>Used together, skills, tactics, and plays form a tree structure with the Play at the root and other behaviors below it. The C++ <code>GameplayModule</code> tells the current play to run, which in turn tells each of its sub-behaviors to run.</p>
<h2>Gameplay structure</h2>
<p>Every behavior in soccer is a state machine that subclasses the main <a class="el" href="classgameplay_1_1fsm_1_1_state_machine.html">StateMachine class</a>. This class has methods for adding states and transitions between them as well as utility methods for showing textual and graphical descriptions of a state machine and it's sub-machines. One nifty usage of this feature is that we can easily view a diagram of every skill, tactic, and play in our library.</p>
<div class="fragment"><div class="line"># Run this in a terminal in the robocup-software folder to make the diagrams</div><div class="line">$ make behavior-diagrams</div></div><!-- fragment --><p>After running the above command, open up the <code>soccer/gameplay/diagrams</code> folder and browse around to see a diagram for each behavior. Below is the state diagram for the <a class="el" href="classgameplay_1_1skills_1_1pivot__kick_1_1_pivot_kick.html">PivotKick</a> behavior. A good exercise if you're new to writing plays is to compare the PivotKick <b>init</b>() method's state machine declarations to what you see in the diagram below.</p>
<div class="image">
<img src="PivotKick-state-diagram.png" alt="PivotKick-state-diagram.png"/>
<div class="caption">
PivotKick state diagram</div></div>
<h2>Creating a Play</h2>
<p>Making a new play is as simple as adding a new python file somewhere inside the <code>soccer/gameplay/plays</code> directory and creating a subclass of <code>Play</code> inside of it. There is no need to register the play, soccer will see the file in that folder and display it in the Plays tab in <code>soccer</code>. Generally when writing a new play, it's a good idea to base its initial structure on an existing play. A good example play to look at is the LineUp play.</p>
<p>Every play begins by declaring a python class that subclasses the Play class:</p>
<div class="fragment"><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyNewPlay(play.Play):</div><div class="line">    <span class="keyword">def </span>__init__(self):</div><div class="line">        <span class="comment"># call superclass constructor</span></div><div class="line">        super().__init__(continuous=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">        <span class="comment"># TODO: declare states and transitions if needed</span></div><div class="line">        <span class="comment">#       see fsm.py for more info on these methods.</span></div><div class="line"></div><div class="line">        <span class="comment"># Most plays transition from Start to Running right away</span></div><div class="line">        self.add_transition(behavior.Behavior.State.start,</div><div class="line">                behavior.Behavior.State.running,</div><div class="line">                <span class="keyword">lambda</span>: <span class="keyword">True</span>,</div>                <span class="stringliteral">&#39;immediately&#39;</span>)</div></div><!-- fragment --><p>After declaring the play, it's time to add in the appropriate states and state transitions to your play. Every subclass of <a class="el" href="classgameplay_1_1behavior_1_1_behavior.html">the Behavior class</a> automatically inherits some pre-defined states including <code>Start</code>, <code>Running</code>, and <code>Completed</code> and is initially started in the <code>Start</code> state. It's your job as the writer of a new play to define a state transition from <code>Start</code> to <code>Running</code> or a substate of <code>Running</code>.</p>
<p>The gameplay system automatically declares three methods for every state added to a behavior: on_enter_&lt;NAME&gt;, on_exit_&lt;NAME&gt;, execute_&lt;NAME&gt;. Where &lt;NAME&gt; is the name of the state. This allows us to conveniently execute code whenever we transition states or have code run repeatedly while we're in the state.</p>
<p>An incredibly simple example of a play that just moves a robot to a certain position on the field could be implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> play</div><div class="line"><span class="keyword">import</span> skills.move</div><div class="line"><span class="keyword">import</span> robocup</div><div class="line"></div><div class="line"><span class="keyword">class </span>MoveOneRobot(play.Play):</div><div class="line">    <span class="keyword">def </span>__init__(self):</div><div class="line">        super().__init__(continuous=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">        self.add_transition(behavior.Behavior.State.start,</div><div class="line">                behavior.Behavior.State.running,</div><div class="line">                <span class="keyword">lambda</span>: <span class="keyword">True</span>,</div><div class="line">                <span class="stringliteral">&#39;immediately&#39;</span>)</div><div class="line"></div><div class="line">    <span class="keyword">def </span>on_enter_running(self):</div><div class="line">        <span class="comment"># Add a &quot;Move&quot; subbehavior that tells a robot to a specified (x, y) location</span></div><div class="line">        m = skills.move.Move(robocup.Point(0, 2))</div><div class="line">        self.add_subbehavior(m, name=<span class="stringliteral">&#39;move&#39;</span>, required=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    <span class="keyword">def </span>on_exit_running(self):</div><div class="line">        <span class="comment"># When the running state is over, we remove the subbehavior</span></div><div class="line">        self.remove_subbehavior(<span class="stringliteral">&#39;move&#39;</span>)</div></div><!-- fragment --><h2>Behavior Sequences</h2>
<p>Behavior Sequences are an alternative to the state-machine based logic found elsewhere in Soccer. Many times we don't need complex transition functions, and simply want to execute behaviors in sequence. We simply model the behavior sequence as a list of behaviors to be executed in order. We can then use these sequences in Plays or Complex behaviors. There are also SingleRobot Behavior Sequences which only allow SingleRobot behaviors.</p>
<p>We can view the lifecycle of the class in its <b>init</b> method: </p><div class="fragment"><div class="line"><span class="keyword">class </span>BehaviorSequence(composite_behavior.CompositeBehavior):</div><div class="line">    <span class="keyword">def </span>__init__(self, behaviors= []):</div><div class="line">        super().__init__(</div><div class="line">            continuous=<span class="keyword">True</span></div><div class="line">        )  <span class="comment"># Note: we don&#39;t know if the sequence will be continuous or not, so we assume it is to be safe</span></div><div class="line"></div><div class="line">        self.behaviors = behaviors</div><div class="line"></div><div class="line">        self._current_behavior_index = -1</div><div class="line"></div><div class="line">        self.add_transition(</div><div class="line">            behavior.Behavior.State.start, behavior.Behavior.State.running,</div><div class="line">            <span class="keyword">lambda</span>: len(self.behaviors) &gt; 0, <span class="stringliteral">&#39;has subbehavior sequence&#39;</span>)</div><div class="line"></div><div class="line">        self.add_transition(</div><div class="line">            behavior.Behavior.State.running, behavior.Behavior.State.completed,</div><div class="line">            <span class="keyword">lambda</span>: self._current_behavior_index &gt;= len(self.behaviors),</div><div class="line">            <span class="stringliteral">&#39;all subbehaviors complete&#39;</span>)</div><div class="line"></div><div class="line">        self.add_transition(</div><div class="line">            behavior.Behavior.State.running, behavior.Behavior.State.failed,</div><div class="line">            <span class="keyword">lambda</span>: self.current_behavior != <span class="keywordtype">None</span> <span class="keywordflow">and</span> self.current_behavior.is_in_state(behavior.Behavior.State.failed),</div><div class="line">            <span class="stringliteral">&#39;subbehavior failed&#39;</span>)</div></div><!-- fragment --><p>The behaviors are added to the sequence, and it executes them one by one. When they are all complete, the sequence ends. Alternatively, if one of the behaviors in the sequence fails then the sequence transitions to the failed state and stops executing behaviors immediately.</p>
<h2>Role Assignment</h2>
<p>When writing a play, you are defining a set of actions that should be taken by different robots on the field. One important thing to note though is that you don't choose which robots will fulfill these roles directly. Instead, you can define what attributes a robot should have in order for them to be a good fit for the role. At each iteration of the main run loop, the role assignment system examines the role requirements for each running behavior and uses an optimal matching algorithm (the <a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">hungarian algorithm</a>) to find the best robot to assign to each role. In order to implement custom assignment logic for your behavior, you'll need to override the <a class="el" href="classgameplay_1_1behavior_1_1_behavior.html#a2c9ebc9a057ad45d702c12cc155f0862">role_requirements() method</a>.</p>
<h2>RoboCup python module</h2>
<p>We use a 3rd-party library called Boost Python to create an interface between the C++ code that makes up the majority of our <code>soccer</code> program and the gameplay system that's written in python. Boost Python is used to create a python module called "robocup" that python code can <em>import</em> in order to access our C++ classes and functions. The C++ classes and functions available to the python interface are created through "wrappers" in the <a href="https://github.com/RoboJackets/robocup-software/blob/master/soccer/gameplay/robocup-py.cpp">robocup-py.cpp</a> file. The "robocup" python module is compiled as a part of our project when you run <code>make</code> and is placed in the <code>run</code> directory as <code>robocup.so</code>. This can be imported like any other python module like so:</p>
<div class="fragment"><div class="line">cd robocup-software</div><div class="line"></div><div class="line"># Ensure that the latest version of the &#39;robocup&#39; python module is built</div><div class="line">make</div><div class="line"></div><div class="line"># The python module is placed in the &#39;run&#39; directory as &#39;robocup.so&#39;</div><div class="line">cd run</div><div class="line"></div><div class="line"># Run python interpreter and import the module</div><div class="line">python3</div><div class="line">import robocup</div><div class="line"></div><div class="line"># Use the help function to see a list of available classes and functions</div><div class="line">help(robocup)</div></div><!-- fragment --><h2>Visualization</h2>
<p>Many plays provide visualizations for the actions they are performing to make it easier for the user to quickly see what's happening. For example, the Defense tactic draws red triangles from opponent robots and the ball to our goal to help visualize our defense's effective coverage. This functionality is provided by the many drawing methods provided by the <a class="el" href="class_system_state.html">SystemState</a> class. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Jul 30 2019 01:21:47 for GT RoboCup SSL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
